{"meta":{"title":"pluto","subtitle":"pluto's blog","description":null,"author":"Tong","url":"https://solitary-s.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-03-16T05:44:28.742Z","updated":"2020-03-16T05:44:28.742Z","comments":false,"path":"/404.html","permalink":"https://solitary-s.github.io//404.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"about","date":"2020-04-11T09:25:30.000Z","updated":"2020-04-11T07:25:58.361Z","comments":true,"path":"about/index.html","permalink":"https://solitary-s.github.io/about/index.html","excerpt":"","text":"个人详细介绍 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"书单","date":"2020-03-16T05:44:28.745Z","updated":"2020-03-16T05:44:28.745Z","comments":false,"path":"books/index.html","permalink":"https://solitary-s.github.io/books/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2020-04-11T09:25:30.000Z","updated":"2020-04-11T07:24:05.115Z","comments":true,"path":"categories/index.html","permalink":"https://solitary-s.github.io/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-04-11T07:28:07.000Z","updated":"2020-04-11T07:28:55.483Z","comments":true,"path":"contact/index.html","permalink":"https://solitary-s.github.io/contact/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friends","date":"2020-04-11T07:29:12.000Z","updated":"2020-04-11T07:31:47.960Z","comments":true,"path":"friends/index.html","permalink":"https://solitary-s.github.io/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"友情链接","date":"2020-03-16T05:44:28.747Z","updated":"2020-03-16T05:44:28.747Z","comments":true,"path":"links/index.html","permalink":"https://solitary-s.github.io/links/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"Repositories","date":"2020-03-16T05:44:28.748Z","updated":"2020-03-16T05:44:28.748Z","comments":false,"path":"repository/index.html","permalink":"https://solitary-s.github.io/repository/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-04-11T10:23:38.000Z","updated":"2020-04-11T07:24:52.132Z","comments":true,"path":"tags/index.html","permalink":"https://solitary-s.github.io/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"Java并发-AQS","slug":"Java并发-AQS","date":"2020-03-10T13:06:16.000Z","updated":"2020-03-16T07:34:03.115Z","comments":true,"path":"2020/03/10/java-bing-fa-aqs/","link":"","permalink":"https://solitary-s.github.io/2020/03/10/java-bing-fa-aqs/","excerpt":"","text":"简介AQS 全称为(AbstractQueuedSynchronizer), AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构建出大量的同步器。 原理AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。 CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。 AQS 组件CountDownLatch用来控制一个线程等待多个线程，维护了一个计数器 cnt，每次调用 countDown()方法会让计数器的值减 1，减到 0 的时候，那些应为调用 await()方法而在等待的线程就会被唤醒 public class CountdownLatchExample { public static void main(String[] args) throws InterruptedException { ExecutorService executorService = Executors.newCachedThreadPool(); CountDownLatch countDownLatch = new CountDownLatch(10); for (int i = 0; i &lt; 10; i++) { executorService.execute(() -&gt; { System.out.print(\"run...\"); countDownLatch.countDown(); }); } countDownLatch.await(); System.out.print(\"end..\"); executorService.shutdown(); } } // run...run...run...run...run...run...run...run...run...run...end..CyclicBarrier用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。和 CountDownLatch 相似，都是通过维护计数器实现的。线程执行 await()方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await()方法而在等待的线程才能继续执行。 public class CyclicBarrierExample { public static void main(String[] args) { CyclicBarrier cyclicBarrier = new CyclicBarrier(10); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) { executorService.execute(() -&gt; { System.out.print(\"before...\"); try { cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } System.out.print(\"after...\"); }); } executorService.shutdown(); } } // before...before...before...before...before...before...before...before...before...before...after...after...after...after...after...after...after...after...after...after...SemaphoreSemaphore 可以控制对互斥资源的访问线程数 以下模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10. public class SemaphoreExample { public static void main(String[] args) { Semaphore semaphore = new Semaphore(3); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) { executorService.execute(() -&gt; { try { semaphore.acquire(); System.out.print(semaphore.availablePermits() + \" \"); } catch (InterruptedException e) { e.printStackTrace(); }finally { semaphore.release(); } }); } executorService.shutdown(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://solitary-s.github.io/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://solitary-s.github.io/tags/Java并发/"}]},{"title":"Java并发-ThreadLocal","slug":"Java并发-ThreadLocal","date":"2020-03-09T13:06:16.000Z","updated":"2020-03-16T07:33:50.182Z","comments":true,"path":"2020/03/09/java-bing-fa-threadlocal/","link":"","permalink":"https://solitary-s.github.io/2020/03/09/java-bing-fa-threadlocal/","excerpt":"","text":"简介通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ JDK 中提供的 ThreadLocal 类正是为了解决这样的问题。 ThreadLocal 类主要解决的就是让每个线程绑定自己的值，可以将 ThreadLocal 类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据 如果你创建了一个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是 ThreadLocal 变量名的由来。他们可以使用 get()和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。 比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。 Demopublic class ThreadLocalTest implements Runnable{ // SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本 // 等同于一下代码 private static final ThreadLocal&lt;SimpleDateFormat> formatter = ThreadLocal.withInitial(() -> new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")); // private static final ThreadLocal&lt;SimpleDateFormat> formatter = new ThreadLocal&lt;SimpleDateFormat>(){ // @Override // protected SimpleDateFormat initialValue() { // return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); // } // }; public static void main(String[] args) throws InterruptedException { ThreadLocalTest obj = new ThreadLocalTest(); for(int i=0 ; i&lt;10; i++){ Thread t = new Thread(obj, \"\"+i); Thread.sleep(new Random().nextInt(1000)); t.start(); } } @Override public void run() { System.out.println(\"Thread Name= \"+Thread.currentThread().getName()+\" default Formatter = \"+formatter.get().toPattern()); try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } //formatter pattern is changed here by thread, but it won't reflect to other threads formatter.set(new SimpleDateFormat(\"yyyyMMddHHmmss\")); System.out.println(\"Thread Name= \"+Thread.currentThread().getName()+\" formatter = \"+formatter.get().toPattern()); } } 原理ThreadLocal 内部维护的是一个类似 Map 的 ThreadLocalMap 数据结构，key 为当前对象的 Thread 对象，值为 Object 对象 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://solitary-s.github.io/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://solitary-s.github.io/tags/Java并发/"}]},{"title":"Java并发-线程池","slug":"Java并发-线程池","date":"2020-03-01T09:52:16.000Z","updated":"2020-03-16T07:32:02.884Z","comments":true,"path":"2020/03/01/java-bing-fa-xian-cheng-chi/","link":"","permalink":"https://solitary-s.github.io/2020/03/01/java-bing-fa-xian-cheng-chi/","excerpt":"","text":"线程池的优点 降低资源消耗 提高响应速度 提供线程可管理性 Executor 框架Executor 框架是 Java5 之后引进的，通过 Executor 来启动线程与使用 Thread 的 start 方法更好，易于管理，效率更好 Executor 框架接口(三大部分) 任务(Runnable、Callable) 执行任务需要实现的Runnable接口或Callable接口。Runnable 接口或 Callable 接口 实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行 任务的执行(Executor) 任务执行的核心为 Executor 和 ExecutorService 接口， ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 两个关键的实现类 异步计算的结果(Future) Future 接口以及 Future 接口的实现类 FutureTask 类可以代表异步计算的接口。当我们把 Runnable 和 Callable 接口的实现类提交给 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。调用 submit() 方法会返回一个 FutureTask 对象 Executor 框架的使用 主线程首先要创建 Runnable 或者 Callable 接口的任务对象 把创建的任务对象交给 ExecutorService 执行 ExecutorService void execute(Runnable command); Future&lt;T> submit(Callable&lt;T> task); Future&lt;T> submit(Runnable task, T result); ExecutorService.submit() 将返回一个实现 Future 接口的对象 FutureTask FutureTask.get()方法来等待任务执行完成，主线程也可以执行 FutureTask.cancel()来取消任务的执行 ThreadPoolExecutor 类线程池实现类 ThreadPoolExecutor 是 Executor 框架最核心的类 构造方法public ThreadPoolExecutor(int corePoolSize, // 线程池的核心线程数量 int maximumPoolSize, // 线程池的最大线程数 long keepAliveTime, // 当线程数大于核心线程数时，多余的空闲线程存活的最长时间 TimeUnit unit, // 时间单位 BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列，用来存储等待执行任务的队列 ThreadFactory threadFactory, // 线程工厂，用来创建线程，一般默认即可 RejectedExecutionHandler handler) { // 拒接策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务 if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; }ThreadPoolExecutor 参数 corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。 maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。 workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，信任就会被存放在队列中。 keepAliveTime:当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime 才会被回收销毁； unit : keepAliveTime 参数的时间单位。 threadFactory :executor 创建新线程的时候会用到。 handler :饱和策略。关于饱和策略下面单独介绍一下。 饱和策略如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时 ThreadPoolExecutor.AbortPolicy: 抛出 RejectedExecutionException 来拒接新任务的处理 ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务，也就是直接在调用 execute 方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。 ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。 ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。 Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略为我们提供可伸缩队列。 使用 ThreadPoolExecutor 构造函数创建线程池好处使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题 不允许使用 Executors 去创建线程池，而是通过 ThreadPoolExecutor 构造函数去创建，规避资源耗尽的风险 FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。 CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。 ThreadPoolExecutor 简单使用public class ThreadPoolExecutorDemo { private static final int CORE_POOL_SIZE = 5; private static final int MAX_POOL_SIZE = 10; private static final int QUEUE_CAPACITY = 100; private static final Long KEEP_ALIVE_TIME = 1L; public static void main(String[] args) { ThreadPoolExecutor executor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY), new ThreadPoolExecutor.CallerRunsPolicy() ); for (int i = 0; i &lt; 10; i++) { Runnable worker = new MyRunnable(\"\" + i); executor.execute(worker); } executor.shutdown(); while(!executor.isTerminated()){ } System.out.println(\"Finished all threads\"); } }public class MyRunnable implements Runnable{ private String command; public MyRunnable(String s){ this.command = s; } @Override public void run() { System.out.println(Thread.currentThread().getName() + \"Start. Time = \" + new Date()); processCommand(); System.out.println(Thread.currentThread().getName() + \"End. Time = \" + new Date()); } private void processCommand(){ try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } } @Override public String toString() { return super.toString(); } }pool-1-thread-1Start. Time = Sun Mar 01 11:06:55 CST 2020 pool-1-thread-3Start. Time = Sun Mar 01 11:06:55 CST 2020 pool-1-thread-2Start. Time = Sun Mar 01 11:06:55 CST 2020 pool-1-thread-4Start. Time = Sun Mar 01 11:06:55 CST 2020 pool-1-thread-5Start. Time = Sun Mar 01 11:06:55 CST 2020 pool-1-thread-1End. Time = Sun Mar 01 11:07:01 CST 2020 pool-1-thread-1Start. Time = Sun Mar 01 11:07:01 CST 2020 pool-1-thread-3End. Time = Sun Mar 01 11:07:01 CST 2020 pool-1-thread-3Start. Time = Sun Mar 01 11:07:01 CST 2020 pool-1-thread-2End. Time = Sun Mar 01 11:07:01 CST 2020 pool-1-thread-2Start. Time = Sun Mar 01 11:07:01 CST 2020 pool-1-thread-4End. Time = Sun Mar 01 11:07:01 CST 2020 pool-1-thread-4Start. Time = Sun Mar 01 11:07:01 CST 2020 pool-1-thread-5End. Time = Sun Mar 01 11:07:01 CST 2020 pool-1-thread-5Start. Time = Sun Mar 01 11:07:01 CST 2020 pool-1-thread-1End. Time = Sun Mar 01 11:07:06 CST 2020 pool-1-thread-3End. Time = Sun Mar 01 11:07:06 CST 2020 pool-1-thread-2End. Time = Sun Mar 01 11:07:06 CST 2020 pool-1-thread-4End. Time = Sun Mar 01 11:07:06 CST 2020 pool-1-thread-5End. Time = Sun Mar 01 11:07:06 CST 2020 Finished all threadsThreadPoolExecutor 简单原理 Runnable VS Callable Runnable 不会返回结果或抛出检查异常，Callable 可以 Executors 可以实现 Runnable 和 Callable 对象之间的转换 execute() VS submit() execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否 submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。 shutdown() VS shutdownNow() shutdown(): 关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。 shutdownNow(): 关闭线程池，线程的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List isTerminated() VS isShutdown() isShutDown(): 当调用 shutdown() 方法后返回为 true。 isTerminated(): 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true Callable 和 ThreadPoolExecutor 简单使用public class CallableDemo { private static final int CORE_POOL_SIZE = 5; private static final int MAX_POOL_SIZE = 10; private static final int QUEUE_CAPACITY = 100; private static final Long KEEP_ALIVE_TIME = 1L; public static final SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); public static void main(String[] args) { ThreadPoolExecutor executor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY), new ThreadPoolExecutor.CallerRunsPolicy() ); List&lt;Future&lt;String&gt;&gt; futures = new ArrayList&lt;&gt;(); Callable&lt;String&gt; callable = new MyCallable(); for (int i = 0; i &lt; 10; i++) { Future&lt;String&gt; future = executor.submit(callable); futures.add(future); } for (Future&lt;String&gt; fut : futures) { try { System.out.println(df.format(new Date()) + \" : \" + fut.get()); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } } //关闭线程池 executor.shutdown(); } }public class MyCallable implements Callable&lt;String&gt; { @Override public String call() throws Exception { Thread.sleep(1000); return Thread.currentThread().getName(); } }2020-03-01 12:59:03 : pool-1-thread-1 2020-03-01 12:59:04 : pool-1-thread-2 2020-03-01 12:59:04 : pool-1-thread-3 2020-03-01 12:59:04 : pool-1-thread-4 2020-03-01 12:59:04 : pool-1-thread-5 2020-03-01 12:59:04 : pool-1-thread-3 2020-03-01 12:59:05 : pool-1-thread-2 2020-03-01 12:59:05 : pool-1-thread-5 2020-03-01 12:59:05 : pool-1-thread-1 2020-03-01 12:59:05 : pool-1-thread-4常见的几种线程池FixedThreadPool 详解public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); } corePoolSize 和 maximumPoolSize 都设置为 nThreads 如果当前运行的线程数小于 corePoolSize， 如果再来新任务的话，就创建新的线程来执行任务 当前运行的线程数等于 corePoolSize 后， 如果再来新任务的话，会将任务加入 LinkedBlockingQueue 线程池中的线程执行完 手头的任务后，会在循环中反复从 LinkedBlockingQueue 中获取任务来执行 缺点：使用的队列 LinkedBlockingQueue 是无限队列，因此不存在任务队列满的情况，运行中 FixedThreadPool 不会拒接任务，在任务比较多的时候会导致 OOM(内存溢出) SingleThreadPool 详解public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); } 只有一个线程的线程池 corePoolSize 和 maximumPoolSize 都设置为 1 缺点：SingleThreadExecutor 使用无界队列 LinkedBlockingQueue 作为线程池的工作队列（队列的容量为 Intger.MAX_VALUE）。SingleThreadExecutor 使用无界队列作为线程池的工作队列会对线程池带来的影响与 FixedThreadPool 相同。说简单点就是可能会导致 OOM CachedThreadPool 详解public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); } CachedThreadPool 的 corePoolSize 被设置为空（0），maximumPoolSize 被设置为 Integer.MAX.VALUE，即它是无界的，这也就意味着如果主线程提交任务的速度高于 maximumPool 中线程处理任务的速度时，CachedThreadPool 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://solitary-s.github.io/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://solitary-s.github.io/tags/Java并发/"}]},{"title":"Json-Jackson的使用","slug":"Json-Jackson的使用","date":"2020-02-03T16:02:16.000Z","updated":"2020-03-16T07:36:29.035Z","comments":true,"path":"2020/02/04/json-jackson-de-shi-yong/","link":"","permalink":"https://solitary-s.github.io/2020/02/04/json-jackson-de-shi-yong/","excerpt":"","text":"Jackson 简介Jackson 是一个简单基于 Java 应用库，Jackson 可以轻松的将 Java 对象转换成 json 对象和 xml 文档，同样也可以将 json、xml 转换成 Java 对象。Jackson 所依赖的 jar 包较少，简单易用并且性能也要相对高些，并且 Jackson 社区相对比较活跃，更新速度也比较快。性能比其他 Json 解析快 maven 依赖&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.3&lt;/version&gt; &lt;/dependency&gt;对象和 JSON 转换// 对象和json的转换 public static void test() throws IOException { // 创建ObjectMapper对象 ObjectMapper objectMapper = new ObjectMapper(); String jsonStudent = \"{\\\"id\\\":10001, \\\"username\\\":\\\"tong\\\", \\\"password\\\":\\\"12345s\\\", \\\"nickname\\\":\\\"logic\\\"}\"; // json 转换成 Java对象 User user = objectMapper.readValue(jsonStudent, User.class); logger.debug(\"student: {}\", user); // Java对象转换成 json final String jsonStr = objectMapper.writeValueAsString(user); logger.debug(\"json : {} \", jsonStr); }集合和 JSON 转换 public static void test01() throws IOException { ObjectMapper mapper = new ObjectMapper(); String jsonString = \"{\\\"draw\\\":1,\\\"recordsTotal\\\":1,\\\"recordsFiltered\\\":1,\\\"data\\\":[{\\\"id\\\":33,\\\"title\\\":\\\"ad1\\\",\\\"subTitle\\\":\\\"ad1\\\",\\\"titleDesc\\\":\\\"ad1\\\",\\\"url\\\":\\\"https://sale.jd.com/act/XkCzhoisOMSW.html\\\",\\\"pic\\\":\\\"https://m.360buyimg.com/babel/jfs/t20164/187/1771326168/92964/b42fade7/5b359ab2N93be3a65.jpg\\\",\\\"pic2\\\":\\\"\\\",\\\"content\\\":\\\"&lt;p&gt;&lt;br&gt;&lt;/p&gt;\\\"}],\\\"error\\\":null}\"; // 反序列化 JSON 到树 JsonNode jsonNode = mapper.readTree(jsonString); // 从树中读取 data 节点 JsonNode jsonData = jsonNode.findPath(\"data\"); System.out.println(jsonData); // 反序列化 JSON 到集合 JavaType javaType = mapper.getTypeFactory().constructParametricType(ArrayList.class, TbContent.class); List&lt;TbContent&gt; tbContents = mapper.readValue(jsonData.toString(), javaType); for (TbContent tbContent : tbContents) { System.out.println(tbContent); } // 序列化集合到 JSON String json = mapper.writeValueAsString(tbContents); System.out.println(json); }Json 注解 @JsonProperty 指定一个属性用于 JSON 映射，可以使用 value 属性值修改 Json 属性名 @JsonIgnore 注解用于排除某个属性，该属性就不会被序列化和反序列化 @JsonIgnoreProperties 注解是类注解。在序列化为 Json 的时候，@JsonIgnoreProperties({“prop1”, “pro2”})会忽略 pro1 和 pro2 两个属性。在从 Json 反序列化 Java 类的时候，@JsonIgnoreProperties(ignoreUnknown=true)会忽略所有没有 setter 和 getter 的属性。 @JsonIgnoreType 类注解，会排除所有指定类型的属性 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Json","slug":"Json","permalink":"https://solitary-s.github.io/categories/Json/"}],"tags":[{"name":"Json","slug":"Json","permalink":"https://solitary-s.github.io/tags/Json/"},{"name":"Jackson","slug":"Jackson","permalink":"https://solitary-s.github.io/tags/Jackson/"}]},{"title":"日志-Log4j","slug":"日志-Log4j","date":"2020-02-03T16:00:16.000Z","updated":"2020-03-16T07:36:45.729Z","comments":true,"path":"2020/02/04/ri-zhi-log4j/","link":"","permalink":"https://solitary-s.github.io/2020/02/04/ri-zhi-log4j/","excerpt":"","text":"Log4j Log4j 全称 Log for java java 语言的日志工具 日志级别 (由高到低) fatal (致命) error 系统上线后一般记录 error 日志 warn info debug trace (堆栈) 调试多线程 Slf4jSimple Loging Facade For Java, 只是接口没有实现，是一个规则，必须搭配其他日志实现方案 maven 依赖&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt;日志附加器在 resource 目录下创建一个 log4j.properties 文件 log4j.rootLogger=INFO, console, file log4j.appender.console=org.apache.log4j.ConsoleAppender log4j.appender.console.layout=org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=%d %p [%c] - %m%n log4j.appender.file=org.apache.log4j.DailyRollingFileAppender log4j.appender.file.File=logs/log.log log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.A3.MaxFileSize=1024KB log4j.appender.A3.MaxBackupIndex=10 log4j.appender.file.layout.ConversionPattern=%d %p [%c] - %m%n日志的使用public static final Logger logger = LoggerFactory.getLogger(JacksonTest.class); logger.debug(\"json : {} \", jsonStr); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"日志","slug":"日志","permalink":"https://solitary-s.github.io/categories/日志/"}],"tags":[{"name":"日志","slug":"日志","permalink":"https://solitary-s.github.io/tags/日志/"},{"name":"Log4j","slug":"Log4j","permalink":"https://solitary-s.github.io/tags/Log4j/"}]},{"title":"测试-JUnit","slug":"测试-JUnit","date":"2020-02-01T16:02:16.000Z","updated":"2020-03-16T07:36:59.439Z","comments":true,"path":"2020/02/02/ce-shi-junit/","link":"","permalink":"https://solitary-s.github.io/2020/02/02/ce-shi-junit/","excerpt":"","text":"TDDTDD 测试驱动编程，编程方法学先写测试用例，再编码 测试 单元测试 白盒测试 可以看到源码 黑盒测试 没有源码，功能测试 灰盒测试 压力测试 并发数的问题 疲劳强度测试 长期稳定运行 7 天一小周期 冒烟测试 对主要流程测试，支付环节，不断点击一个功能 集成测试 完整功能的测试，最重要的是测试，整体业务流程 回归测试 增加一个功能 自动化测试 编码、场景设计 JUnitJUnit 是用于编写和运行可重复的自动化测试的开源测试框架，这样可以保证我们的代码按预期工作。JUnit 可广泛用于工业和作为支架(从命令行)或 IDE(如 IDEA)内单独的 Java 程序。 maven 依赖&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;JUnit 的使用public class MyTest { @Before public void before(){ System.out.println(\"执行before()方法\"); } @After public void after(){ System.out.println(\"执行after()方法\"); } @Test public void testHi(){ System.out.println(\"hi junit\"); } }JUnit 断言@Test public void testAssert() { String obj1 = \"junit\"; String obj2 = \"junit\"; String obj3 = \"test\"; String obj4 = \"test\"; String obj5 = null; int var1 = 1; int var2 = 2; int[] arithmetic1 = {1, 2, 3}; int[] arithmetic2 = {1, 2, 3}; assertEquals(obj1, obj2); // 断言两个值相等 assertSame(obj3, obj4); // 断言两个对象引用相同的对象 assertNotSame(obj2, obj4); assertNotNull(obj1); assertNull(obj5); assertTrue(\"为真\", var1 == var2); assertArrayEquals(arithmetic1, arithmetic2); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JUnit","slug":"JUnit","permalink":"https://solitary-s.github.io/categories/JUnit/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://solitary-s.github.io/tags/测试/"},{"name":"JUnit","slug":"JUnit","permalink":"https://solitary-s.github.io/tags/JUnit/"}]},{"title":"springboot-服务端异常的统一处理","slug":"springboot-服务端异常的统一处理","date":"2020-01-31T16:03:16.000Z","updated":"2020-02-23T03:08:12.361Z","comments":true,"path":"2020/02/01/springboot-fu-wu-duan-yi-chang-de-tong-yi-chu-li/","link":"","permalink":"https://solitary-s.github.io/2020/02/01/springboot-fu-wu-duan-yi-chang-de-tong-yi-chu-li/","excerpt":"","text":"@ControllerAdvice@ControllerAdvice，是Spring3.2提供的新注解,它是一个Controller增强器,可对Controller中被 @RequestMapping注解的方法加一些逻辑处理。最常用的就是异常处理 统一的异常处理 需要配合@ExceptionHandler使用 当将异常抛到Controller时, 可以对异常进行统一处理 规定返回的json格式或是跳转到一个错误页面 @RestControllerAdvice 包含了@ControllerAdvice和@ResponseBody @Data public class MyException extends RuntimeException { private long code; private String msg; public MyException(long code, String msg){ this.code = code; this.msg = msg; } }@ControllerAdvice @ResponseBody public class GlobalExceptionInterceptor { @ExceptionHandler(value = MyException.class) public String exceptionHandler(HttpServletRequest request, Exception e) throws JsonProcessingException { String failMsg = null; // 判断异常类型，返回json数据或者是页面 if(e instanceof MyException){ failMsg = ((MyException) e).getMsg(); } return failMsg; } } @RestController@RequestMapping(“student”)public class HelloController { @PostMapping(\"addStudent\") public String addStudent(@RequestBody @Valid Student student){ return null; } @GetMapping(\"hello\") public String hello() throws MyException { throw new MyException(101L, \"自定义异常\"); }}``` document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"springboot","slug":"springboot","permalink":"https://solitary-s.github.io/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://solitary-s.github.io/tags/springboot/"},{"name":"异常处理","slug":"异常处理","permalink":"https://solitary-s.github.io/tags/异常处理/"}]},{"title":"Docker安装MySQL Redis和RabbitMQ","slug":"Docker安装MySQL Redis和RabbitMQ","date":"2020-01-31T16:02:16.000Z","updated":"2020-03-16T07:29:30.221Z","comments":true,"path":"2020/02/01/docker-an-zhuang-mysql-redis-he-rabbitmq/","link":"","permalink":"https://solitary-s.github.io/2020/02/01/docker-an-zhuang-mysql-redis-he-rabbitmq/","excerpt":"","text":"docker-compose.yml 文件version: '3' services: mysql-server: image: mysql:5.7 container_name: mysql-server restart: always ports: - 3306:3306 environment: MYSQL_ROOT_PASSWORD: 123456 redis-server: image: redis:latest container_name: redis-server restart: always ports: - 6379:6379 rabbitmq-server: image: rabbitmq:management container_name: rabbitmq-server restart: always ports: - 5672:5672 - 15672:15672 启动容器：docker-compose up -d 数据层 ip端口 MySQL http://localhost:3306 root/123456 Redis http://localhost:6379 RabbitMQ http://localhost:15672 guest/guest document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Docker","slug":"Docker","permalink":"https://solitary-s.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://solitary-s.github.io/tags/Docker/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://solitary-s.github.io/tags/环境搭建/"}]},{"title":"swagger2-接口文档引擎","slug":"swagger2-接口文档引擎","date":"2020-01-31T16:02:16.000Z","updated":"2020-02-23T02:57:42.119Z","comments":true,"path":"2020/02/01/swagger2-jie-kou-wen-dang-yin-qing/","link":"","permalink":"https://solitary-s.github.io/2020/02/01/swagger2-jie-kou-wen-dang-yin-qing/","excerpt":"","text":"swagger2 简介swagger2是接口文档引擎，虽然帮助我们解决了接口文档的 编写，但是swagger2是==侵入式==的，最明显的就是代码植入性比较强。 maven 依赖&lt;!-- Swagger2 Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Swagger2 End --&gt;Swagger2配置@Configuration public class Swagger2Config { /** * RequestHandlerSelectors.basePackage(\"com.aloneness.controller\") 为controller包路径 * * @return */ @Bean public Docket createRestApi(){ return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\"com.aloneness.controller\")) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo(){ return new ApiInfoBuilder() .title(\"MySwagger2 API 文档\") .description(\"MySwagger2 API 网关接口，www.aloneness.cn\") .termsOfServiceUrl(\"http://www.aloneness.cn\") .version(\"1.0.0\") .build(); } }启动swagger2加上注解@EnableSwagger2 使用swagger2@ApiOperation(value = \"用户注册\", notes = \"用户注册，注意用户名和邮箱不要重复\") @PostMapping(\"reg\") public void reg(@ApiParam(name = \"user\", value = \"用户模型\")User user){ }swagger2 常用注解 @Api: 修饰整个类，描述整个Controller的作用 @ApiOperation: 描述一个类的一个方法，或者说一个接口 @ApiParam: 用在请求方法中，描述参数信息 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"swagger2","slug":"swagger2","permalink":"https://solitary-s.github.io/categories/swagger2/"}],"tags":[{"name":"swagger2","slug":"swagger2","permalink":"https://solitary-s.github.io/tags/swagger2/"}]},{"title":"Java线程-线程基础","slug":"Java线程-线程基础","date":"2020-01-03T16:06:16.000Z","updated":"2020-03-16T07:33:53.369Z","comments":true,"path":"2020/01/04/java-xian-cheng-xian-cheng-ji-chu/","link":"","permalink":"https://solitary-s.github.io/2020/01/04/java-xian-cheng-xian-cheng-ji-chu/","excerpt":"","text":"1. 线程状态(State)线程状态有六种，在 java.lang.Thread 源码中 public enum State { NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED; } 新建(New)线程刚创建，还未启动 Thread thread = new Thread(); System.out.println(thread.getState()); // NEW可运行(Runnable) 这个状态的线程，其正在 JVM 中执行，但是这个”执行”，不一定是真的在运行，也有可能是在等待 CPU 资源 包含了操作系统线程状态中的 Running 和 Ready, Ready 表示资源一到可以随时执行，Running 表示真正的执行中 Thread thread = new Thread(); thread.start(); System.out.println(thread.getState()); // RUNNABLE阻塞(Blocked)等待获取一个排它锁，如果其他线程释放了锁就会结束此状态 public class MyThread extends Thread { private byte[] lock = new byte[0]; public MyThread(byte[] lock) { this.lock = lock; } @Override public void run() { synchronized (lock){ try { Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"done\"); } } }public class Test { public static void main(String[] args) throws InterruptedException { byte[] lock = new byte[0]; // 节约资源，只能成三条操作码，Object object = new Object()生成7条操作码 MyThread thread1 = new MyThread(lock); thread1.start(); MyThread thread2 = new MyThread(lock); thread2.start(); Thread.sleep(1000);//等一会再检查状态 System.out.println(thread2.getState()); // BLOCKED } }线程 1 先执行，执行到 synchronized 获取了 Lock 锁，线程 2 后执行，想要获取 Lock 锁，获取失败，进入阻塞状态 无限期等待(Waiting)进入到此状态，一定执行了一些代码： Object.wait(): 当一个线程执行了 Object.wait(), 它一定等待另一个线程执行 Object.notify()或 Object.notifyAll()进行唤醒，否则一直等待 public class MyThread extends Thread { private byte[] lock = new byte[0]; public MyThread(byte[] lock) { this.lock = lock; } @Override public void run() { synchronized (lock){ try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } }public class Test { public static void main(String[] args) throws InterruptedException { byte[] lock = new byte[0]; MyThread thread1 = new MyThread(lock); thread1.start(); Thread.sleep(100); System.out.println(thread1.getState()); // WAITING synchronized (lock){ lock.notify(); } Thread.sleep(100); System.out.println(thread1.getState()); // TERMINATED } } Thread.join(): 一个线程 thread，其在主线程中被执行了 thread.join()的时候，主线程即会等待该线程执行完成 public class MyThread extends Thread { private byte[] lock = new byte[0]; public MyThread(byte[] lock) { this.lock = lock; } @Override public void run() { try { System.out.println(\"thread1 run\"); Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } } }public class MyThread1 extends Thread { private Thread thread; public MyThread1(Thread thread){ this.thread = thread; } @Override public void run() { try { thread.join(); System.out.println(\"thread2 run\"); } catch (InterruptedException e) { e.printStackTrace(); } } }public class Test { public static void main(String[] args) throws InterruptedException { byte[] lock = new byte[0]; MyThread thread = new MyThread(lock); thread.start(); MyThread1 thread1 = new MyThread1(thread); thread1.start(); Thread.sleep(100); System.out.println(thread1.getState()); // WAITING } } LockSupport.park(): 当一个线程执行了 LockSupport.park()的时候，其在等待执行 LockSupport.unpark(thread) public class MyThread extends Thread { private byte[] lock = new byte[0]; public MyThread(byte[] lock) { this.lock = lock; } @Override public void run() { LockSupport.park(); } }public class Test { public static void main(String[] args) throws InterruptedException { byte[] lock = new byte[0]; MyThread thread = new MyThread(lock); thread.start(); Thread.sleep(100); System.out.println(thread.getState()); // WAITING LockSupport.unpark(thread); Thread.sleep(100); System.out.println(thread.getState()); // TERMINATED } } 进入方法 退出方法 没有设置 Timeout 参数的 Object.wait()方法 Object.notify()/Object.notifyAll() 没有设置 Timeout 参数的 Thread.join()方法 被调用的线程执行完毕 LockSupport.park()方法 LockSupport.unpark(Thread) 限期等待(Timed Waiting)无需等待其他线程显示地唤醒，在一定时间之后会被系统自动唤醒。调用 Thread.sleep()方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait()方法使线程进入限期等待或者无限期等待是，常常用“挂起一个线程”进行描述 Thread.sleep(long) public class MyThread3 extends Thread{ @Override public void run() { try { Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } } }public class Test { public static void main(String[] args) throws InterruptedException { Thread thread = new MyThread3(); thread.start(); Thread.sleep(100); System.out.println(thread.getState()); // TIMED_WAITING } } Object.wait(long) public class MyThread extends Thread { private byte[] lock = new byte[0]; public MyThread(byte[] lock) { this.lock = lock; } @Override public void run() { synchronized (lock){ try { // 注意，此处1s之后线程醒来，会重新尝试去获取锁，如果拿不到，后面的代码也不执行 lock.wait(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"lock end\"); } } }public class Test { public static void main(String[] args) throws InterruptedException { byte[] lock = new byte[0]; Thread thread = new MyThread(lock); thread.start(); Thread.sleep(100); System.out.println(thread.getState()); // TIMED_WAITING Thread.sleep(2000); System.out.println(thread.getState()); // TERMINATED } } Thread.join(long) LockSupport.parkNanos() LockSupport.parkUntil() 进入方法 退出方法 Thread.sleep()方法 时间结束 设置 Timeout 参数的 Object.wait()方法 时间结束/Object.notify()/Object.notifyAll() 设置 Timeout 参数的 Thread.join()方法 时间结束被调用的线程执行完毕 LockSupport.parkNanos()方法 LockSupport.unpark(Thread) LockSupport.parkUntil()方法 LockSupport.unpark(Thread) 死亡(Terminated)可以是线程结束任务之后自己结束，或者产生了异常而结束 2. 使用线程1. 实现 Runnable 接口public class MyRunnable implements Runnable { @Override public void run() { } } MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); 2. 实现 Callable 接口，与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装public class MyCallable implements Callable&lt;String> { @Override public String call() throws Exception { Thread.sleep(1000); return Thread.currentThread().getName(); } } public class CallableTest { public static void main(String[] args) throws ExecutionException, InterruptedException { Callable&lt;String&gt; callable = new MyCallable(); FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(callable); Thread thread = new Thread(futureTask); thread.setName(\"CallableTest\"); thread.start(); System.out.println(futureTask.get()); // CallableTest } }3. 继承 Thread 类public class MyThread extends Thread { public void run(){ } } Thread thread = new Thread(); Daemon 守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。 当所有非守护线程结束时，线程也就终止，同时会杀死所有守护线程 使用 setDaemon()方法将一个线程设置为守护线程 sleep() 让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态 sleep()方法不会释放“锁标志”, 如果有synchronized同步块，其他线程仍然不能访问共享数据 wait() wait() 方法需要和 notify() 及 notifyAll() 两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在 synchronized 语句块内使用。也就是说，调用 wait()，notify() 和 notifyAll() 的任务在调用这些方法前必须拥有对象的锁。注意，它们都是 Object 类的方法，而不是 Thread 类的方法。 wait() 方法与 sleep() 方法的不同之处在于，wait()方法会释放对象的“锁标志”。当调用某一对象的 wait() 方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了 notify() 方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的 notifyAll() 方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。 除了使用 notify() 和 notifyAll() 方法，还可以使用带毫秒参数的 wait(long timeout) 方法，效果是在延迟 timeout 毫秒后，被暂停的线程将被恢复到锁标志等待池。 此外，wait()，notify() 及 notifyAll() 只能在 synchronized 语句中使用，但是如果使用的是 ReenTrantLock 实现同步，该如何达到这三个方法的效果呢？解决方法是使用 ReenTrantLock.newCondition() 获取一个 Condition 类对象，然后 Condition 的 await()，signal() 以及 signalAll() 分别对应上面的三个方法 yield()yield() 方法和 sleep() 方法类似，也不会释放“锁标志”，区别在于，它没有参数，即 yield() 方法只是使当前线程重新回到可执行状态，所以执行 yield() 的线程有可能在进入到可执行状态后马上又被执行，另外 yield() 方法只能使同优先级或者高优先级的线程得到执行机会，这也和 sleep() 方法不同。 join()join() 方法会使当前线程等待调用 join() 方法的线程结束后才能继续执行 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java线程","slug":"Java线程","permalink":"https://solitary-s.github.io/categories/Java线程/"}],"tags":[{"name":"Java线程","slug":"Java线程","permalink":"https://solitary-s.github.io/tags/Java线程/"}]},{"title":"Java并发-synchronized关键字","slug":"Java并发-synchronized关键字","date":"2020-01-03T16:06:16.000Z","updated":"2020-03-16T07:31:59.936Z","comments":true,"path":"2020/01/04/java-bing-fa-synchronized-guan-jian-zi/","link":"","permalink":"https://solitary-s.github.io/2020/01/04/java-bing-fa-synchronized-guan-jian-zi/","excerpt":"","text":"简述synchronized 是一个同步、重量级锁。synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行 synchronized 关键字的使用修饰实例方法给当前对象实例加锁，进入同步代码需要获取当前对象实例的锁 public synchronized void test01(){ count--; System.out.println(Thread.currentThread().getName() + \" count=\" + count); } 修饰静态方法给当前类加锁，会作用于类的所有对象实例 public synchronized static void test01(){ count--; System.out.println(Thread.currentThread().getName() + \" count=\" + count); 修饰代码块指定加锁对象，进入同步代码块前要获得给定对象的锁 synchronized (Test01.class){ count++; }Demo双重校验锁实现单例模式 public class Singleton { private volatile static Singleton instance; private Singleton(){ } public static Singleton getInstance(){ if (instance == null){ synchronized (Singleton.class){ if(instance == null){ instance = new Singleton(); } } } return instance; } }instance 使用 volatile 修饰防止指令重排序，new Singleton()分三步 为 uniqueInstance 分配内存空间 初始化 uniqueInstance 将 uniqueInstance 指向分配的内存地址 脏读public class Account { String name; double balance; public synchronized void set(String name, double balance){ this.name = name; try{ Thread.sleep(2000); }catch (InterruptedException e){ e.printStackTrace(); } this.balance = balance; } public double getBalance(String name){ return this.balance; } public static void main(String[] args) { Account account = new Account(); new Thread(()->account.set(\"zhangsan\", 100.0)).start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(account.getBalance(\"zhangsan\")); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(account.getBalance(\"zhangsan\")); } } 锁是可重入的一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁，也就是说 synchronized 获得的锁是可重入的 public class T { public synchronized void m1(){ System.out.println(\"m1 start\"); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } m2(); } public synchronized void m2(){ try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"m2\"); } public static void main(String[] args) { T t = new T(); new Thread(()-&gt;t.m1()).start(); new Thread(()-&gt;t.m1()).start(); } }实现原理synchronized 的实现属于 JVM 层面 同步代码块的情况public class SynchronizedDemo { public void method() { synchronized (this) { System.out.println(\"synchronized code block\"); } } }使用 javap -c -s -v -l SynchronizedDemo.class 命令查看字节码synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor 对象存在于每个 Java 对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因) 的持有权。当计数器为 0 则可以成功获取，获取后将锁计数器设为 1 也就是加 1。相应的在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。 修饰方法的情况public class SynchronizedDemo01 { public synchronized void method() { System.out.println(\"synchronized code block\"); } } synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 synchronized 和 ReentrantLock 的区别 两者都是可重入锁 可重入锁是指自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想获取这个对象的锁的时候还是可以获取的，如果锁不可以重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。 synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。 ReentrantLock 比 synchronized 增加了一些高级功能 等待可中断 通过 lock.lockInterruptibly()，正在等待的线程可以选择放弃等待，改为处理其他事情 可实现公平锁 ReentrantLock 可以指定是公平锁还是非公平锁。而 synchronized 只能是非公平锁。公平锁就是先等待的线程先获得锁。ReentrantLock 默认情况是非公平的，可以通过 ReentrantLock 类的 ReentrantLock(boolean fair)构造方法来指定是否是公平的。 可实现选择性通知 synchronized 关键字与 wait()和 notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock 类当然也可以实现，但是需要借助于 Condition 接口与 newCondition() 方法。Condition 是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个 Lock 对象中可以创建多个 Condition 实例（即对象监视器），线程对象可以注册在指定的 Condition 中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用 notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用 ReentrantLock 类结合 Condition 实例可以实现“选择性通知” ，这个功能非常重要，而且是 Condition 接口默认提供的。而 synchronized 关键字就相当于整个 Lock 对象中只有一个 Condition 实例，所有的线程都注册在它一个身上。如果执行 notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而 Condition 实例的 signalAll()方法 只会唤醒注册在该 Condition 实例中的所有等待线程。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://solitary-s.github.io/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://solitary-s.github.io/tags/Java并发/"}]},{"title":"Java并发-volatile关键字","slug":"Java并发-volatile关键字","date":"2020-01-03T16:06:16.000Z","updated":"2020-03-16T07:32:11.685Z","comments":true,"path":"2020/01/04/java-bing-fa-volatile-guan-jian-zi/","link":"","permalink":"https://solitary-s.github.io/2020/01/04/java-bing-fa-volatile-guan-jian-zi/","excerpt":"","text":"简述被 volatile 修饰的共享变量，具有以下两大特性： 保证了不同线程对该变量操作的内存可见性 禁止指令重排序 Java 内存模型 JMM(Java 内存模型)规定所有的变量都是存在主存中的，每个线程又包含自己的工作内存，所有的线程的操作都是以工作内存为主的，他们只能访问自己的工作内存，且工作前后都要把值同步到主存中。 在线程执行的时候，首先会从主存中 read 变量值，再 load 到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内存的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。 Java 内存模型虽然加快了速度，但是带来了一些问题i = i + 1; 假设 i 初始值为 0，当两个线程执行的时候会出现以下情况: 线程1：load i from 主存 // i = 0 i + 1 // i = 1 线程2：laod i from 主存 // i = 0 i + 1 // i = 1 线程1：save i to 主存 线程2：save i to 主存以上的情况会造成缓存不一致问题 volatile 解决，保证变量的可见性 解决这个问题，就需要把变量声明为 volatile，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。 Java 内存模型的三大特性原子性(Atomicity)java 中，对于读取和赋值操作都是原子性操作，要做一定做完，要么就没有执行。比如 i = 2;就是简单的读取操作，必定是原子操作， j = i 不是原子操作，分两步，先读取 i 的值，然后再将值赋给 j，JMM 只是实现了基本的原子性，如果是 i++这样的操作，需要借助 synchronized 和 Lock 保证整块代码的原子性。线程在释放锁之前，必定会把 i 的值刷回到主存的。 可见性(Visibility)Java 就是利用 volatile 来提供可见性的。当一个变量被 volatile 修饰时，那么对它的修改会立刻刷新到主存，当其他线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。其实通过 synchronized 和 Lock 也能保证可见性，线程释放锁之前，会报共享变量值都刷回到主存，但是 synchronized 和 Lock 的开销都更大。 有序性(Ordering)JMM 是允许编译器和处理器对指令重排序的，但是规定了 as-if-serial 含义，即不管怎么重排序，程序的执行结果不能改变。JMM 保证了重排序不会影响单线程的执行，但是在多线程中却容易出现问题。 synchronized 关键字和 volatile 关键字的区别 volatile 关键字是线程同步的轻量级实现，所以 volatile 性能肯定比 synchronized 关键字要好。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。synchronized 关键字在 JavaSE1.6 之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。 多线程访问 volatile 关键字不会发生阻塞，而 synchronized 关键字可能会发生阻塞。 volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。 volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://solitary-s.github.io/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://solitary-s.github.io/tags/Java并发/"}]},{"title":"Java8-函数式编程接口","slug":"Java8-函数式编程接口","date":"2020-01-02T16:06:16.000Z","updated":"2020-03-16T07:31:35.728Z","comments":true,"path":"2020/01/03/java8-han-shu-shi-bian-cheng-jie-kou/","link":"","permalink":"https://solitary-s.github.io/2020/01/03/java8-han-shu-shi-bian-cheng-jie-kou/","excerpt":"","text":"1. Customer 接口 消费者的含义，接受参数而不返回 @FunctionalInterface public interface Consumer&lt;T> { void accept(T t); default Consumer&lt;T> andThen(Consumer&lt;? super T> after) { Objects.requireNonNull(after); return (T t) -> { accept(t); after.accept(t); }; } } 简化 public static void main(String[] args) { Consumer c = System.out::println; c.accept(\"hello world\"); } 可以多重处理 public static void main(String[] args) { Consumer c = System.out::println; c.andThen(c).andThen(c).accept(\"hello world\"); } 结果为 hello world hello world hello world 2. Function 接口 代表函数的含义，即有输入，也有输出，使用更加灵活 @FunctionalInterface public interface Function&lt;T, R> { R apply(T t); default &lt;V> Function&lt;V, R> compose(Function&lt;? super V, ? extends T> before) { Objects.requireNonNull(before); return (V v) -> apply(before.apply(v)); } default &lt;V> Function&lt;T, V> andThen(Function&lt;? super R, ? extends V> after) { Objects.requireNonNull(after); return (T t) -> after.apply(apply(t)); } static &lt;T> Function&lt;T, T> identity() { return t -> t; } } 简化 public static void main(String[] args) { Function&lt;Integer, Integer> f1 = i -> i + i; Function&lt;Integer, Integer> f2 = i -> i * i; Consumer c = System.out::println; c.accept(f1.andThen(f2).apply(2)); // 16 } 3. Optional 接口 Optional 本质是一个容器，你可以将你的变量交由它进行封装，这样我们就不用显式对原变量进行 null 检测，防止出现各种空指针异常。 获取一个学生的考试分数 public Integer getScore(Student student){ return Optional.ofNullable(student) .map(Student::getScore) .orElse(null); } orElse 如果为 null 就返回默认值 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java8","slug":"Java8","permalink":"https://solitary-s.github.io/categories/Java8/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://solitary-s.github.io/tags/Java8/"}]},{"title":"Mybatis-标签使用","slug":"Mybatis-标签使用","date":"2019-12-31T16:03:16.000Z","updated":"2020-02-24T14:03:05.630Z","comments":true,"path":"2020/01/01/mybatis-biao-qian-shi-yong/","link":"","permalink":"https://solitary-s.github.io/2020/01/01/mybatis-biao-qian-shi-yong/","excerpt":"","text":"对象中包含对象和集合的映射对象使用association标签关联 &lt;resultMap id=\"baseResultMap\" type=\"com.aloneness.vhr.model.Menu\" &gt; &lt;id column=\"id\" property=\"id\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"url\" property=\"url\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"path\" property=\"path\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"component\" property=\"component\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"name\" property=\"name\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"iconCls\" property=\"iconCls\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"parentId\" property=\"parentId\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"enabled\" property=\"enabled\" jdbcType=\"BIT\" /&gt; &lt;association property=\"meta\" javaType=\"org.javaboy.vhr.model.Meta\"&gt; &lt;result column=\"keepAlive\" property=\"keepAlive\" jdbcType=\"BIT\" /&gt; &lt;result column=\"requireAuth\" property=\"requireAuth\" jdbcType=\"BIT\" /&gt; &lt;/association&gt; &lt;/resultMap&gt;list对象 使用collection &lt;resultMap id=\"menu2\" type=\"org.javaboy.vhr.model.Menu\" extends=\"baseResultMap\"&gt; &lt;collection property=\"children\" ofType=\"com.aloneness.vhr.model.Menu\"&gt; &lt;id column=\"id2\" property=\"id\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"url2\" property=\"url\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"path2\" property=\"path\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"component2\" property=\"component\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"name2\" property=\"name\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"iconCls2\" property=\"iconCls\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"parentId2\" property=\"parentId\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"enabled2\" property=\"enabled\" jdbcType=\"BIT\" /&gt; &lt;association property=\"meta\" javaType=\"org.javaboy.vhr.model.Meta\"&gt; &lt;result column=\"keepAlive2\" property=\"keepAlive\" jdbcType=\"BIT\" /&gt; &lt;result column=\"requireAuth2\" property=\"requireAuth\" jdbcType=\"BIT\" /&gt; &lt;/association&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"getMenusByHrId\" resultMap=\"menu2\"&gt; SELECT DISTINCT m1.*, m2.`id` AS id2, m2.`component` AS component2, m2.`enabled` AS enabled2, m2.`iconCls` AS iconCls2, m2.`keepAlive` AS keepAlive2, m2.`name` AS name2, m2.`parentId` AS parentId2, m2.`requireAuth` AS requireAuth2, m2.`path` AS path2 FROM menu m1, menu m2, hr_role hrr, menu_role mr WHERE m1.`id` = m2.`parentId` AND hrr.`hrid` = #{hrid} and hrr.`rid`=mr.`rid` and mr.`mid`=m2.`id` and m2.`enabled`=true order by m1.`id`,m2.`id` &lt;/select&gt;foreach标签 属性 作用 collection 用于迭代的集合，可以使用@Param标注 item 本次迭代的元素 open 语句的开始 ‘(‘ close 语句的结束 ‘)’ separator 每次迭代给sql语句后面加入字符 ‘,’ index 该元素指定的key 批量插入注意括号的位置 &lt;foreach collection=\"list\" item=\"item\" separator=\",\"> （#{item}） &lt;/foreach> 会解析成如下方式：INSERT INTO user(user_name) VALUES(‘zhangsan’),(‘lisi’),(‘wangwu’) 构建in条件语句&lt;foreach collection=\"list\" item=\"item\" open=\"(\" separator=\",\" close=\")\"> #{item} &lt;/foreach> 会解析成如下方式：SELECT * FROM user WHERE user_name in (‘zhangsan’,’lisi’,’wangwu’) trim标签一般用户去除sql语句中多余的and的关键字，逗号，或者给sql语句前拼接where、set以及values() 等前缀，或者添加) 等后缀，可用于选择性插入、更新、删除或者条件查询等操作。 属性 描述 prefix 给sql语句拼接的前缀 suffix 给sql语句拼接的后缀 prefixOverrides 去除sql语句前面的关键字或者字符，该关键字或者字符由prefixOverrides属性指定，假设该属性指定位and, 当sql语句的开头为and，trim标签将会去除and suffixOverrides 去除sql语句后面的关键字或者字符，该关键字或者字符由prefixOverrides属性指定 where标签可以完成类似的功能 selectKey标签详解数据库主键包括自增和非自增，有时候新增一条数据不仅仅知道成功就行了，后边的逻辑可能还需要这个新增的主键，这时候再查询数据库就有点耗时力，我们可以采用selectKey来帮助我们获取新增的主键 自增类型的主键获取&lt;insert id=\"insert\" parameterType=\"com.example.wjtweb.pojo.Goods\"&gt; &lt;selectKey keyProperty=\"id\" order=\"AFTER\" resultType=\"Integer\"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; INSERT INTO Goods (MID,GNAME,PRICE,AMOUNT,imageName) VALUES (#{mid},#{gname},#{price},#{amount},#{imageName}); &lt;/insert&gt; @Data public class Goods { //自增主键 private Integer id; private String mid; private String gname; private String price; private String amount; private String imageName; } SELECT LAST_INSERT_ID(): MySQL的一个函数，得到刚insert进去记录的主键值，只适用于主键自增 keyProperty: 将查询到的主键值设置到Java对象的Id order after 表示 SELECT LAST_INSERT_ID()在insert执行之后执行，多用于自增主键 before 表示 SELECT LAST_INSERT_ID()在insert执行之前执行，这样就拿不到主键了，不适合自增类型的主键 非自增类型的主键获取&lt;insert id=\"insert\" parameterType=\"com.soft.mybatis.model.Customer\"&gt; &lt;!-- 跟自增主键方式相比，这里的不同之处只有两点 1 insert语句需要写id字段了，并且 values里面也不能省略 2 selectKey 的order属性需要写成BEFORE 因为这样才能将生成的uuid主键放入到model中， 这样后面的insert的values里面的id才不会获取为空 跟自增主键相比就这点区别，当然了这里的获取主键id的方式为 select uuid() 当然也可以另写别生成函数。--&gt; &lt;selectKey keyProperty=\"id\" order=\"BEFORE\" resultType=\"String\"&gt; select uuid() &lt;/selectKey&gt; insert into t_customer (id,c_name,c_sex,c_ceroNo,c_ceroType,c_age) values (#{id},#{name},#{sex},#{ceroNo},#{ceroType},#{age}) &lt;/insert&gt; select uuid()：MySQL的一个函数，得到UUID唯一值 树型接口的处理例如：部门管理 &lt;select id=\"getAllDepartmentsByParentId\" resultMap=\"DepartmentWithChildren\"> select * from department where parentId=#{pid}; &lt;/select> &lt;resultMap id=\"DepartmentWithChildren\" type=\"org.javaboy.vhr.model.Department\" extends=\"BaseResultMap\"> &lt;collection property=\"children\" ofType=\"org.javaboy.vhr.model.Department\" select=\"org.javaboy.vhr.mapper.DepartmentMapper.getAllDepartmentsByParentId\" column=\"id\"/> &lt;/resultMap> List&lt;Department> getAllDepartmentsByParentId(Integer pid); public class Department implements Serializable { private Integer id; private String name; private Integer parentId; private String depPath; private Boolean enabled; private Boolean isParent; private List&lt;Department&gt; children = new ArrayList&lt;&gt;(); private Integer result; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://solitary-s.github.io/categories/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://solitary-s.github.io/tags/Mybatis/"}]},{"title":"Java代码整洁-消除if else","slug":"代码整洁-消除if else","date":"2019-12-31T15:18:16.000Z","updated":"2020-02-21T15:35:49.178Z","comments":true,"path":"2019/12/31/dai-ma-zheng-ji-xiao-chu-if-else/","link":"","permalink":"https://solitary-s.github.io/2019/12/31/dai-ma-zheng-ji-xiao-chu-if-else/","excerpt":"","text":"1. if else 繁琐代码 public String judge(String roleName){ String result = \"\"; if(roleName.equals(\"ROLE_ROOT_ADMIN\")){ result = \"ROLE_ROOT_ADMIN: \"+\"has AAA permission\"; }else if(roleName.equals(\"ROLE_ORDER_ADMIN\")){ result = \"ROLE_ORDER_ADMIN: \"+\"has BBB permission\"; }else if(roleName.equals(\"ROLE_NORMAL\")){ result = \"ROLE_NORMAL: \"+\"has CCC permission\"; }else{ result = \"XXX\"; } return result; } 2. 使用枚举优化代码 定义了一个公用接口 RoleOperation public interface RoleOperation { String op(); } 定义枚举 public enum RoleEnum implements RoleOperation{ ROLE_ROOT_ADMIN { @Override public String op() { return \"ROLE_ROOT_ADMIN: \"+\"has AAA permission\"; } }, ROLE_ORDER_ADMIN { @Override public String op() { return \"ROLE_ORDER_ADMIN: \"+\"has BBB permission\"; } }, ROLE_NORMAL { @Override public String op() { return \"ROLE_NORMAL: \"+\"has CCC permission\"; } }, ROLE_OTHER { @Override public String op() { return \"XXX\"; } }; } 判断就可以很简单了 public String judge(String roleName){ return RoleEnum.valueOf(roleName).op(); } 3. 使用工厂模式 定义各种角色 public class RootAdminRole implements RoleOperation { private String roleName; public RootAdminRole(String roleName){ this.roleName = roleName; } @Override public String op() { return roleName + \"has AAA permission\"; } } public class OrderAdminRole implements RoleOperation { private String roleName; public OrderAdminRole(String roleName){ this.roleName = roleName; } @Override public String op() { return roleName + \"has BBB permission\"; } } public class NormalAdminRole implements RoleOperation { private String roleName; public NormalAdminRole(String roleName){ this.roleName = roleName; } @Override public String op() { return roleName + \"has CCC permission\"; } } 定义工厂 public class RoleFactory { static Map&lt;String, RoleOperation> roleOperationMap = new HashMap&lt;>(); static { roleOperationMap.put(\"ROLE_ROOT_ADMIN\", new RootAdminRole(\"ROLE_ROOT_ADMIN\")); roleOperationMap.put(\"ROLE_ORDER_ADMIN\", new RootAdminRole(\"ROLE_ORDER_ADMIN\")); roleOperationMap.put(\"ROLE_NORMAL\", new RootAdminRole(\"ROLE_NORMAL\")); } public static RoleOperation getOp(String roleName){ return roleOperationMap.get(roleName); } } 判断就可以简单了 public String judge(String roleName){ return RoleFactory.getOp(roleName).op(); } 4. 使用策略模式 先定义一个 Context public class RoleContext { private RoleOperation roleOperation; public RoleContext(RoleOperation roleOperation){ this.roleOperation = roleOperation; } public String execute(){ return roleOperation.op(); } } 传入不同的角色就可以得到不同的操作结果 public String judge(RoleOperation roleOperation){ RoleContext roleContext = new RoleContext(roleOperation); return roleContext.execute(); } public static void main(String[] args) { JudgeRole judgeRole = new JudgeRole(); String result1 = judgeRole.judge(new RootAdminRole(\"ROOT_ADMIN_ROLE\")); System.out.println(result1); String result2 = judgeRole.judge(new OrderAdminRole(\"ORDER_ADMIN_ROLE\")); System.out.println(result2); String result3 = judgeRole.judge(new NormalAdminRole(\"NORMAL_ADMIN_ROLE\")); System.out.println(result3); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"代码整洁","slug":"代码整洁","permalink":"https://solitary-s.github.io/categories/代码整洁/"}],"tags":[{"name":"代码整洁","slug":"代码整洁","permalink":"https://solitary-s.github.io/tags/代码整洁/"}]},{"title":"Java代码整洁-复杂的参数校验","slug":"代码整洁-复杂的参数校验","date":"2019-12-31T09:18:16.000Z","updated":"2020-02-21T15:35:28.448Z","comments":true,"path":"2019/12/31/dai-ma-zheng-ji-fu-za-de-can-shu-xiao-yan/","link":"","permalink":"https://solitary-s.github.io/2019/12/31/dai-ma-zheng-ji-fu-za-de-can-shu-xiao-yan/","excerpt":"","text":"1. 场景一个请求往往会传入许多参数，但是都需要进行校验，但是总不能把所有参数进行 if 校验，这非常繁琐，我们可以使用注解更简单的实现 2. 注解进行校验 对传入的实体类的字段加入注解 public class Student { @NotNull(message = \"姓名为null\") @NotEmpty(message = \"姓名不能为空字符串\") private String name; @NotNull(message = \"分数不能为null\") @Min(value = 0, message = \"分数只能在0到100之间\") @Max(value = 100, message = \"分数只能在0到100之间\") private Integer score; @NotNull(message = \"手机号不能为null\") @NotEmpty(message = \"手机号不能为空字符串\") @Length(min = 11, max = 11, message = \"手机号长度只能为11位\") private String mobile; } 在对象入口处加入@Vaild注解 @PostMapping(\"addStudent\") public String addStudent(@RequestBody @Valid Student student){ return null; } 发送请求的时候就会报 400 的错误 3. 配置全局统一异常拦截器上述返回的信息太复杂，我们可以配置统一异常拦截器，简化返回的错误信息 @ControllerAdvice @ResponseBody public class GlobalExceptionInterceptor { @ExceptionHandler(value = Exception.class) public String exceptionHandler(HttpServletRequest request, Exception e){ String failMsg = null; if(e instanceof MethodArgumentNotValidException){ failMsg = ((MethodArgumentNotValidException) e).getBindingResult().getFieldError().getDefaultMessage(); } return failMsg; } } 直接返回错误信息 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"代码整洁","slug":"代码整洁","permalink":"https://solitary-s.github.io/categories/代码整洁/"}],"tags":[{"name":"代码整洁","slug":"代码整洁","permalink":"https://solitary-s.github.io/tags/代码整洁/"}]},{"title":"设计模式-单例模式的八种写法","slug":"设计模式-单例模式的八种写法","date":"2019-12-30T13:50:16.000Z","updated":"2020-03-16T07:33:44.008Z","comments":true,"path":"2019/12/30/she-ji-mo-shi-dan-li-mo-shi-de-ba-chong-xie-fa/","link":"","permalink":"https://solitary-s.github.io/2019/12/30/she-ji-mo-shi-dan-li-mo-shi-de-ba-chong-xie-fa/","excerpt":"","text":"1、饿汉式(静态常量)[可用] 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。 缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。 public class Singleton { private final static Singleton INSTANCE = new Singleton(); private Singleton(){} public static Singleton getInstance(){ return INSTANCE; } } 2、饿汉式(静态代码块)[可用]这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。 public class Singleton { private static Singleton instance; static { instance = new Singleton(); } private Singleton(){} public static Singleton getInstance(){ return instance; } } 3、懒汉式(线程不安全)[不可用]这种写法起到了 Lazy Loading 的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了 if (singleton == null) 判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式 public class Singleton { private static Singleton instance; private Singleton(){} public static Singleton getInstance(){ if(instance == null){ instance= new Singleton(); } return instance; } }4、懒汉式(线程安全，同步方法)[不推荐用]解决上面第三种实现方式的线程不安全问题，做个线程同步就可以了，于是就对 getInstance() 方法进行了线程同步。 缺点：效率太低了，每个线程在想获得类的实例时候，执行 getInstance() 方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低要改进 package com.aloneness.designModel; public class Singleton { private static Singleton instance; private Singleton(){} public static synchronized Singleton getInstance(){ if(instance == null){ instance= new Singleton(); } return instance; } } 5. 懒汉式(线程安全，同步代码块)[不可用]由于第四种实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。但是这种同步并不能起到线程同步的作用。跟第 3 种实现方式遇到的情形一致，假如一个线程进入了 if (singleton == null) 判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。 public class Singleton { private static Singleton instance; private Singleton(){} public static Singleton getInstance(){ if(instance == null){ synchronized (Singleton.class){ instance= new Singleton(); } } return instance; } }6.双重检查[推荐用]Double-Check 概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次 if (singleton == null) 检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象。 优点：线程安全；延迟加载；效率较高。 package com.aloneness.designModel; public class Singleton { private static volatile Singleton instance; private Singleton(){} public static Singleton getInstance(){ if(instance == null){ synchronized (Singleton.class){ if(instance == null){ instance= new Singleton(); } } } return instance; } } 7.静态内部类[推荐用]这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要 Singleton 类被装载就会实例化，没有 Lazy-Loading 的作用，而静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 优点：避免了线程不安全，延迟加载，效率高 public class Singleton { private Singleton(){} private static class SingletonInstance{ private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance(){ return SingletonInstance.INSTANCE; } }8. 枚举[推荐用]借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在 JDK1.5 中才添加，所以在实际项目开发中，很少见人这么写过 public enum Singleton { INSTANCE; public void whateverMethod() { } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://solitary-s.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://solitary-s.github.io/tags/设计模式/"},{"name":"单例模式","slug":"单例模式","permalink":"https://solitary-s.github.io/tags/单例模式/"}]},{"title":"Java8-LocalDateTime","slug":"Java8-LocalDateTime","date":"2019-12-30T09:18:16.000Z","updated":"2020-01-01T10:11:38.748Z","comments":true,"path":"2019/12/30/java8-localdatetime/","link":"","permalink":"https://solitary-s.github.io/2019/12/30/java8-localdatetime/","excerpt":"","text":"1. Date类的难以使用 难以读懂返回的结果public class BigDecimalStudy { public static void main(String[] args) { Date date = new Date(); System.out.println(\"当前时间\" + date); // 当前时间Mon Dec 30 17:22:22 CST 2019 System.out.println(\"年份\" + date.getYear()); // 年份119 System.out.println(\"月份\" + date.getMonth()); // 月份11 } } 太多的方法已被弃用，构造函数也被弃用 2. LocalDateTime 获取当前时刻非常直观public class BigDecimalStudy { public static void main(String[] args) { LocalDateTime localDateTime = LocalDateTime.now(); System.out.println(\"当前时间: \" + localDateTime); System.out.println(\"年: \" + localDateTime.getYear()); System.out.println(\"月: \" + localDateTime.getMonth()); System.out.println(\"日: \" + localDateTime.getDayOfMonth()); System.out.println(\"时: \" + localDateTime.getHour()); System.out.println(\"分: \" + localDateTime.getMinute()); System.out.println(\"秒: \" + localDateTime.getSecond()); } } 结果为： 当前时间: 2019-12-30T17:55:22.574 年: 2019 月: DECEMBER 日: 30 时: 17 分: 55 秒: 22 构造一个指定的日期非常方便public class BigDecimalStudy { public static void main(String[] args) { LocalDateTime localDateTime = LocalDateTime.of(2019, Month.DECEMBER, 12, 8, 12, 12); System.out.println(localDateTime); } } - 修改日期也非常的方便 ```java public class BigDecimalStudy { public static void main(String[] args) { LocalDateTime localDateTime = LocalDateTime.of(2019, Month.DECEMBER, 12, 8, 12, 12); System.out.println(localDateTime.minusYears(1)); // 减少一年 2019-12-12 08:12:12 System.out.println(localDateTime.plusDays(1)); // 增加一天 2018-12-12T08:12:12 System.out.println(localDateTime.withYear(2020)); // 直接修改年份 2020-12-12T08:12:12 } } 格式化日期public class BigDecimalStudy { public static void main(String[] args) { LocalDateTime localDateTime = LocalDateTime.now(); String result1 = localDateTime.format(DateTimeFormatter.ISO_DATE); String result2 = localDateTime.format(DateTimeFormatter.BASIC_ISO_DATE); String result3 = localDateTime.format(DateTimeFormatter.ofPattern(\"yyyy/MM/DD\")); System.out.println(result1); // 2020-01-01 System.out.println(result2); // 20200101 System.out.println(result3); // 2020/01/01 } } 时间反解析public class BigDecimalStudy { public static void main(String[] args) { LocalDateTime time = LocalDateTime.parse(\"2019--12--12 11:12\", DateTimeFormatter.ofPattern(\"yyyy--MM--dd HH:mm\")); System.out.println(time); // 2019-12-12T11:12 } } 3. 线程安全性问题 Date时间类是可变类，线程不安全 LocalDateTime是线程安全的 SimpleDateFormat也是线程不安全的 DateTimeFormatter，是线程安全的 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java8","slug":"Java8","permalink":"https://solitary-s.github.io/categories/Java8/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://solitary-s.github.io/tags/Java8/"}]},{"title":"Java基础-BigDecimal","slug":"Java基础-BigDecimal","date":"2019-12-30T09:03:16.000Z","updated":"2019-12-30T09:04:20.479Z","comments":true,"path":"2019/12/30/java-ji-chu-bigdecimal/","link":"","permalink":"https://solitary-s.github.io/2019/12/30/java-ji-chu-bigdecimal/","excerpt":"","text":"1. 为什么使用BigDecimal 关于浮点数在计算机是无法准确表示的，例如，0.1 只能表示一个近似值 浮点数double和float的计算结果偶尔会出现不确定性public class BigDecimalStudy { public static void main(String[] args) { double num1 = 0.000001; // 实际结果是 9.999999999999999E-5，而不是0.0001 System.out.println(num1 * 100); } } 因此，double和float并不适合精确的计算，在商业计算中需要精确的计算，需要使用java.math.BigDecimal2. 关于BigDecimal BigDecimal的构造方法有很多，但最好使用new BigDecimal(String val) BigDecimal的加减乘除public class BigDecimalStudy { public static void main(String[] args) { BigDecimal num1 = new BigDecimal(\"0.001\"); System.out.println(num1.multiply(new BigDecimal(\"100\"))); // 0.100 System.out.println(num1.divide(new BigDecimal(\"100\"))); // 0.00001 System.out.println(num1.add(new BigDecimal(\"100\"))); // 100.001 System.out.println(num1.subtract(new BigDecimal(\"100\"))); // -99.999 } } BigDecimal的比较大小public class BigDecimalStudy { public static void main(String[] args) { BigDecimal num1 = new BigDecimal(\"100.01\"); System.out.println(num1.compareTo(new BigDecimal(\"100\")) == 1); // a > b System.out.println(num1.compareTo(new BigDecimal(\"100.01\")) == 0); // a = b System.out.println(num1.compareTo(new BigDecimal(\"100.02\")) == -1); // a &lt; b } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://solitary-s.github.io/categories/Java基础/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://solitary-s.github.io/tags/Java基础/"}]},{"title":"Hexo的安装和基本使用","slug":"Hexo的安装和基本使用","date":"2019-11-30T13:30:16.000Z","updated":"2020-03-16T07:33:46.349Z","comments":true,"path":"2019/11/30/hexo-de-an-zhuang-he-ji-ben-shi-yong/","link":"","permalink":"https://solitary-s.github.io/2019/11/30/hexo-de-an-zhuang-he-ji-ben-shi-yong/","excerpt":"","text":"Hexo 的安装前提安装 node.js，自带 npm $ npm install -g hexo # 全局安装Hexo Hexo 初始化执行以下命令，初始化文件夹，会生成一些基本的文件夹 $ hexo init 修改 Hexo 的主题推荐一款主题 pure，地址：https://github.com/cofess/hexo-theme-pure hexo 的主题官网 https://hexo.io/themes/ 将主题下载到 hexo 的 theme 目录下 修改_config.yml 文件中的 theme 字段 例如 theme: landscape 执行 hexo clean 清理一下 public 内容，然后在生成和发布 Hexo 更换主题注意事项更换主题时出现WARN No layout: index.html，因为 theme: 字段和对应相应的文件夹不一致，主题改为和文件夹名一直即可 Hexo 推送到 gitee 上用 Github 作为仓库，访问速度实在太慢了，这里推荐使用 Gitee，速度较快 安装 hexo-git 插件 npm install hexo-deployer-git --save 在 Git 创建仓库，注意仓库名字和用户名称要一致，否则 Gitee Pages 会创建错误，样式路径有问题 修改配置文件_config.yml deploy: type: git repository: https://gitee.com/aloneness/aloneness.git branch: master 推送完成后点击，点击服务-&gt;Gitee Pages 生成，每次推送完成后都需要手工更新才能生效 Hexo 基本命令最好在 git bash 命令窗口输入 在 HEXO 根目录输入即可 hexo new \"My New Post\" #新建文章 hexo new page \"pageName\" #新建页面 hexo clean # 清理 hexo generate = hexo g #生成静态页面至public目录 hexo server = hexo s #开启预览访问端口（默认端口4000，'ctrl + c'关闭server） hexo deploy hexo d #部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 #组合命令 hexo s -g #生成并本地预览 hexo d -g #生成并上传Hexo 写文章文章的格式 --- title: postName #文章页面上的显示名称，一般是中文 date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改 categories: 默认分类 #分类 tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格 description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面 --- 以下是正文注意事项每次远程推动，github 中的 domain 都会消失解决： 需要在source目录下新建一个文件CNAME(无需后缀) Window 批处理命令本地部署@echo off D: cd D:\\code\\blog\\hexo hexo clean&amp;&amp;hexo g&amp;&amp;hexo s 部署到 Gitee@echo off D: cd D:\\code\\blog\\hexo hexo clean&amp;&amp;hexo g&amp;&amp;hexo d document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://solitary-s.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://solitary-s.github.io/tags/Hexo/"}]}],"categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://solitary-s.github.io/categories/Java并发/"},{"name":"Json","slug":"Json","permalink":"https://solitary-s.github.io/categories/Json/"},{"name":"日志","slug":"日志","permalink":"https://solitary-s.github.io/categories/日志/"},{"name":"JUnit","slug":"JUnit","permalink":"https://solitary-s.github.io/categories/JUnit/"},{"name":"springboot","slug":"springboot","permalink":"https://solitary-s.github.io/categories/springboot/"},{"name":"Docker","slug":"Docker","permalink":"https://solitary-s.github.io/categories/Docker/"},{"name":"swagger2","slug":"swagger2","permalink":"https://solitary-s.github.io/categories/swagger2/"},{"name":"Java线程","slug":"Java线程","permalink":"https://solitary-s.github.io/categories/Java线程/"},{"name":"Java8","slug":"Java8","permalink":"https://solitary-s.github.io/categories/Java8/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://solitary-s.github.io/categories/Mybatis/"},{"name":"代码整洁","slug":"代码整洁","permalink":"https://solitary-s.github.io/categories/代码整洁/"},{"name":"设计模式","slug":"设计模式","permalink":"https://solitary-s.github.io/categories/设计模式/"},{"name":"Java基础","slug":"Java基础","permalink":"https://solitary-s.github.io/categories/Java基础/"},{"name":"Hexo","slug":"Hexo","permalink":"https://solitary-s.github.io/categories/Hexo/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://solitary-s.github.io/tags/Java并发/"},{"name":"Json","slug":"Json","permalink":"https://solitary-s.github.io/tags/Json/"},{"name":"Jackson","slug":"Jackson","permalink":"https://solitary-s.github.io/tags/Jackson/"},{"name":"日志","slug":"日志","permalink":"https://solitary-s.github.io/tags/日志/"},{"name":"Log4j","slug":"Log4j","permalink":"https://solitary-s.github.io/tags/Log4j/"},{"name":"测试","slug":"测试","permalink":"https://solitary-s.github.io/tags/测试/"},{"name":"JUnit","slug":"JUnit","permalink":"https://solitary-s.github.io/tags/JUnit/"},{"name":"springboot","slug":"springboot","permalink":"https://solitary-s.github.io/tags/springboot/"},{"name":"异常处理","slug":"异常处理","permalink":"https://solitary-s.github.io/tags/异常处理/"},{"name":"Docker","slug":"Docker","permalink":"https://solitary-s.github.io/tags/Docker/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://solitary-s.github.io/tags/环境搭建/"},{"name":"swagger2","slug":"swagger2","permalink":"https://solitary-s.github.io/tags/swagger2/"},{"name":"Java线程","slug":"Java线程","permalink":"https://solitary-s.github.io/tags/Java线程/"},{"name":"Java8","slug":"Java8","permalink":"https://solitary-s.github.io/tags/Java8/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://solitary-s.github.io/tags/Mybatis/"},{"name":"代码整洁","slug":"代码整洁","permalink":"https://solitary-s.github.io/tags/代码整洁/"},{"name":"设计模式","slug":"设计模式","permalink":"https://solitary-s.github.io/tags/设计模式/"},{"name":"单例模式","slug":"单例模式","permalink":"https://solitary-s.github.io/tags/单例模式/"},{"name":"Java基础","slug":"Java基础","permalink":"https://solitary-s.github.io/tags/Java基础/"},{"name":"Hexo","slug":"Hexo","permalink":"https://solitary-s.github.io/tags/Hexo/"}]}